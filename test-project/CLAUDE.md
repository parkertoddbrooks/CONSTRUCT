<!-- 
╔══════════════════════════════════════════════════════════════════════════════╗
║                           DO NOT EDIT THIS FILE                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║ This is a GENERATED file, like a compiled binary. Manual edits will be lost. ║
║                                                                              ║
║ To modify patterns:                                                          ║
║ 1. Edit .construct/patterns.yaml for project-specific rules                  ║
║ 2. Create new plugins in CONSTRUCT-LAB/patterns/plugins/                     ║
║ 3. Run: construct-patterns regenerate                                        ║
║                                                                              ║
║ Think of this like Photoshop's .exe - you don't edit the binary!           ║
║                                                                              ║
║ See: CONSTRUCT-CORE/patterns/PATTERN-GUIDE.md for customization help        ║
╚══════════════════════════════════════════════════════════════════════════════╝
-->

# CONSTRUCT Development Context

## Universal Development Principles

These core principles apply to ALL development work, regardless of language or platform:

### ✅ DO: Foundation Rules
- **Never break existing tests** - Changes must maintain backward compatibility
- **Document why, not what** - Code should be self-explanatory, comments explain reasoning
- **Error handling is mandatory** - All failure modes must be handled gracefully
- **Security first** - Never expose secrets, validate all inputs, follow security best practices
- **Performance awareness** - Consider impact of changes on system performance

### ❌ DON'T: Universal Anti-patterns
- Hardcoded values that should be configurable
- Silent failures without error reporting
- Breaking changes without proper versioning
- Security vulnerabilities (exposed secrets, unvalidated inputs)
- Code without proper testing

## Multi-Context Awareness

This context system understands your entire project ecosystem. When you mention files, entities, or tasks, I'll automatically apply the appropriate patterns based on:

- **File extensions** (*.swift, *.cs, *.ts, *.sh, etc.)
- **Directory structure** (CONSTRUCT/**, Models/, Services/, etc.)
- **Project type** (iOS app, web API, full-stack application)
- **Task context** (adding features, fixing bugs, refactoring)

## Pattern System Overview

Your development patterns are organized as plugins that can be mixed and matched based on your project needs:

### Base Patterns (Always Active)
- Universal development principles
- Security and performance standards
- Documentation requirements
- Testing standards

### Language Patterns
- Swift/iOS development patterns
- C#/.NET backend patterns
- TypeScript/JavaScript patterns
- Shell scripting standards

### Architectural Patterns
- MVVM for client applications
- Clean Architecture for backends
- Microservices patterns
- API design standards

### Cross-Platform Patterns
- Model synchronization across stack
- API contract management
- Multi-language coordination

### Tooling Patterns
- CONSTRUCT development workflow
- CI/CD pipeline standards
- Development tools and scripts

## How Pattern Selection Works

Patterns are automatically activated based on your project configuration and the files you're working with. You can also explicitly enable/disable patterns by updating your project's pattern configuration.

### Dynamic Context Application
When you mention specific tasks or files, I'll automatically focus on the relevant patterns:

- Working on a Swift View → Swift language + MVVM patterns
- Updating an API endpoint → Backend patterns + cross-platform considerations
- Writing shell scripts → Shell scripting + tooling patterns
- CONSTRUCT development → CONSTRUCT-specific workflow patterns

## Development Quality Standards

### Code Quality
- All code must be readable and maintainable
- Follow language-specific style guides and conventions
- Use appropriate design patterns for the context
- Implement proper error handling and logging

### Testing Requirements
- Unit tests for business logic
- Integration tests for API endpoints
- UI tests for critical user flows
- Performance tests for bottlenecks

### Documentation Standards
- README files for all projects and major components
- API documentation for public interfaces
- Architectural decision records for significant choices
- Code comments for complex logic or business rules

### Security Standards
- Never commit secrets or API keys
- Validate all user inputs
- Use parameterized queries for database access
- Implement proper authentication and authorization
- Follow OWASP guidelines for web applications

## Pattern Configuration

Below you'll see which patterns are currently active for your project. You can toggle patterns on/off by editing your project's `.construct/patterns.yaml` file and regenerating this context.

To modify patterns:
1. Edit `.construct/patterns.yaml` for project-specific rules
2. Create new plugins in `CONSTRUCT-LAB/patterns/plugins/` for reusable patterns
3. Run `construct-patterns regenerate` to update this file

**Remember**: This file is generated automatically. Don't edit it directly - use the pattern configuration system instead.

## 🧠 Context Intelligence

### Active Language Contexts
Based on your project structure, I'll apply the appropriate patterns:

| File Pattern | Context Applied |
|-------------|-----------------|
| *.swift, *.xcodeproj | Swift patterns |
| *.cs, *.csproj | C# patterns |
| *.ts, *.tsx | TypeScript patterns |
| CONSTRUCT/**/*.sh | CONSTRUCT development |

### Cross-Platform Awareness
When you mention entities that exist across your stack, I'll consider all implementations:
- "User model" → Check Swift, C#, and TypeScript versions
- "API endpoint" → Consider backend implementation and client consumers
- "Update schema" → Propagate through all layers


## 🎛️ Pattern Configuration

### Active Patterns (Toggle ✓/✗ to enable/disable)
- ✓ tooling/shell-scripting
- ✓ cross-platform/model-sync
- ✓ tooling/construct-dev
- ✓ languages/swift


# [SHELL] Modern Shell Scripting Standards

## When to Use
- When writing or modifying shell scripts (*.sh files)
- When creating bash automation or tooling
- For any shell-based scripting tasks

## Essential Patterns

### ✅ DO: Script Structure
```bash
#!/bin/bash

# Script Name - Brief Description
# Detailed explanation of what this script does

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
```

### ✅ DO: Error Handling
- Always use `set -e` for automatic error handling
- Check exit codes and provide feedback
- Provide meaningful error messages with context
- Use colored output for status indicators

### ✅ DO: Function Documentation
```bash
# Function description
# Parameters:
#   $1 - Description of first parameter
#   $2 - Description of second parameter  
# Returns:
#   0 on success, 1 on failure
function_name() {
    local param1="$1"
    local param2="$2"
    
    # Validation
    if [ -z "$param1" ]; then
        echo -e "${RED}❌ Error: param1 required${NC}" >&2
        return 1
    fi
    
    # Implementation
    echo -e "${GREEN}✅ Success${NC}"
    return 0
}
```

### ✅ DO: Variable Naming
- Use UPPER_CASE for global variables and environment variables
- Use local variables in functions
- Provide clear, descriptive variable names
- Quote variables to handle spaces: `"$variable"`

### ✅ DO: Path Handling
- Use relative paths and configuration
- Resolve paths dynamically, never hardcode
- Use `$(cd ... && pwd)` for absolute path resolution

### ❌ DON'T: Anti-patterns
- Hardcoded paths (breaks portability)
- Scripts without `set -e` (silent failures)
- Functions without documentation
- Global variables without UPPER_CASE naming
- Commands without error checking
- Silent operations (no user feedback)
- Unquoted variables that might contain spaces

### ❌ DON'T: Bad Examples
```bash
# BAD: Hardcoded paths
SCRIPT_DIR="/Users/username/project/scripts"

# BAD: No error handling
#!/bin/bash
# Missing: set -e
command_that_might_fail
next_command  # Runs even if previous failed

# BAD: No validation
cp "$1" "$2"  # No check if parameters exist

# BAD: Silent operations
find . -name "*.tmp" -delete  # No feedback to user

# BAD: Global variables without clear naming
result="some value"  # Should be RESULT or local

# BAD: Functions without documentation
process_files() {
    # What does this do? What parameters? What returns?
}
```

## Configuration-Driven Patterns

### ✅ DO: External Configuration
```bash
# Load configuration from external files
load_config() {
    local config_file="$PROJECT_ROOT/config/settings.yaml"
    
    if [ ! -f "$config_file" ]; then
        echo -e "${RED}❌ Config file not found: $config_file${NC}" >&2
        return 1
    fi
    
    # Parse and apply configuration
}
```

### ✅ DO: Help and Usage
```bash
# Show help if requested
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: $0 [options]"
    echo "Description of script and options"
    echo ""
    echo "Options:"
    echo "  --help, -h    Show this help"
    exit 0
fi
```

## Library Integration

### ✅ DO: Source Library Functions
```bash
# Source library functions (with validation)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Source common libraries
if [ -f "$PROJECT_ROOT/lib/common.sh" ]; then
    source "$PROJECT_ROOT/lib/common.sh"
else
    echo "❌ Error: Required library not found: lib/common.sh" >&2
    exit 1
fi
```

### ✅ DO: Reusable Functions
- Extract common patterns into lib/ functions
- Share validation logic across scripts
- Create utilities for file analysis and processing

## Output Standards

### ✅ DO: Consistent Output Format
```bash
echo -e "${BLUE}🔍 Starting process...${NC}"
echo -e "${YELLOW}⚠️ Warning message${NC}"
echo -e "${RED}❌ Error message${NC}"
echo -e "${GREEN}✅ Success message${NC}"
```

### ✅ DO: Status Indicators
- Use emoji and colors for clear status
- Provide progress feedback for long operations
- Show summary results at completion

## Integration
This pattern activates when:
- Working on files with `.sh` extension
- Creating bash scripts or automation
- Writing shell-based tooling

# [CROSS-PLATFORM] Model Synchronization

## When to Use
- When working with data models that exist across multiple languages/platforms
- When updating APIs that affect multiple client implementations
- When coordinating changes across full-stack applications

## Model Change Checklist

When updating any data model, consider ALL representations:

### ✅ DO: Complete Model Updates
- [ ] Update backend model (C#/Python/Node.js/etc.)
- [ ] Update database schema/migration
- [ ] Update API DTOs/contracts
- [ ] Update frontend models (Swift/TypeScript/Kotlin/etc.)
- [ ] Update API client code
- [ ] Update tests across all platforms
- [ ] Update API documentation/OpenAPI spec
- [ ] Consider backward compatibility

### ✅ DO: Validation Across Stack
- Verify serialization compatibility between all layers
- Test API contracts work with all client implementations
- Ensure database constraints align with model rules
- Validate type mappings between languages

## Common Change Patterns

### 1. Adding a Field
**Impact**: Propagates through entire stack
**Considerations**:
- Backend: Add field with appropriate default value
- Database: Migration with default or nullable
- API: Update DTOs, ensure backward compatibility
- Clients: Update models, handle missing field gracefully
- Tests: Update all model-related tests

### 2. Renaming a Field
**Impact**: Breaking change requiring API versioning
**Considerations**:
- Plan migration strategy
- Consider supporting both old and new names temporarily
- Update API documentation with deprecation notices
- Coordinate client updates

### 3. Removing a Field
**Impact**: Breaking change, check for dependencies
**Considerations**:
- Audit all usages across platforms
- Deprecate before removing
- Ensure no client code depends on the field
- Update database to remove column safely

### 4. Type Changes
**Impact**: Potential serialization issues
**Considerations**:
- Validate serialization compatibility
- Test edge cases and boundary values
- Consider data migration needs
- Update validation rules consistently

## Language-Specific Considerations

### Swift/iOS Models
```swift
// Codable properties for API compatibility
struct User: Codable {
    let id: UUID
    let email: String
    let profilePictureURL: String?  // Optional for backward compatibility
}
```

### C#/.NET Models
```csharp
// Entity and DTO separation
public class User 
{
    public Guid Id { get; set; }
    public string Email { get; set; } = string.Empty;
    public string? ProfilePictureUrl { get; set; }  // Nullable for compatibility
}
```

### TypeScript Models
```typescript
// Interface for type safety
interface User {
    id: string;
    email: string;
    profilePictureURL?: string;  // Optional for compatibility
}
```

## API Versioning Strategy

### ✅ DO: Version Management
- Use semantic versioning for API changes
- Maintain backward compatibility when possible
- Document breaking changes clearly
- Provide migration guides for major versions

### ✅ DO: Contract Testing
- Test API contracts across all client implementations
- Validate serialization/deserialization works correctly
- Ensure error responses are handled consistently
- Test edge cases and error conditions

## Cross-Platform Validation

### ✅ DO: Consistency Checks
- Model field names match across platforms (considering naming conventions)
- Data types are appropriately mapped
- Validation rules are consistent
- Error handling patterns align

### ✅ DO: Documentation Sync
- Keep API documentation updated with all changes
- Document platform-specific considerations
- Maintain examples for each client platform
- Update integration guides

## Integration Commands

When I detect multi-platform model updates, I'll guide through:
1. **Backend Changes**: Entity, DTO, validation, migration
2. **API Layer**: Contract updates, documentation, versioning
3. **Client Updates**: Model updates, API client changes, tests
4. **Database**: Schema changes, data migration, constraints
5. **Testing**: Integration tests, contract validation, edge cases

## Common Scenarios

### "Update User model everywhere"
I'll guide through updating the User model across your entire stack with appropriate considerations for each platform.

### "Add new field to Product"
I'll help ensure the new field is added consistently across backend, API, and all client implementations.

### "Change data type for timestamp"
I'll validate the type change works across all platforms and guide through necessary migrations.

## Integration
This pattern activates when:
- Mentioning models that exist across multiple platforms
- Requesting changes that affect multiple languages
- Working on API endpoints consumed by multiple clients
- Discussing database schema changes that affect client code

# [CONSTRUCT] CONSTRUCT Development Rules

## When to Use
- When working on files in `CONSTRUCT/**/*.sh`
- When modifying CONSTRUCT scripts, libraries, or configurations
- When contributing to the CONSTRUCT development system itself

## Symlink and Promotion Rules

### ✅ DO: Symlink Management
- Create new version in LAB, test, then promote to CORE
- Maintain symlink integrity - they point to CORE
- Use the promotion workflow for CORE updates
- Update READMEs in CORE, symlinks auto-reflect changes
- Keep AI documentation symlinked for consistency
- Use ./tools/promote-to-core.sh for tested changes
- Use -sym.ext naming only for actual symlinks to CORE
- Check pre-commit validates symlink naming integrity

### ❌ DON'T: Symlink Anti-patterns
- Edit a symlinked file directly
- Replace a symlink with a regular file
- Commit changes to symlinked files
- Edit symlinked READMEs directly in LAB
- Break symlinks by replacing with regular files
- Manually copy files from LAB to CORE
- Create files named *-sym.* that aren't symlinks
- Copy a *-sym file without preserving the link

## Shell/Python Architecture Rules

### ✅ DO: Architecture Best Practices
- Use relative paths and configuration
- set -e and proper error messages
- Shared functions in lib/
- Configuration in config/ directory
- Use get_construct_root() and validation functions
- Function headers with purpose and parameters
- Clear variable scoping and naming (UPPER_CASE for globals)
- Check exit codes and provide feedback
- Colored output with status indicators

### ❌ DON'T: Architecture Anti-patterns
- Hardcoded paths in scripts
- Scripts without error handling
- Duplicate logic across scripts
- Configuration scattered in scripts
- Scripts that assume specific directory structure
- Functions without documentation
- Global variables without UPPER_CASE
- Commands without error checking
- Silent failures

## CONSTRUCT-Specific Rules

### ✅ DO: Template Independence
- Read-only analysis of USER-project-files/
- Test templates work independently
- Scripts that work for template users
- Use PROJECT-TEMPLATE placeholders

### ❌ DON'T: Template Contamination
- Modify USER-project-files/ from CONSTRUCT scripts
- Template changes without testing
- Scripts that only work in development
- Hardcoded USER project names

## Quality Gate Rules

### ✅ DO: Quality Assurance
- Use pre-commit hooks for validation
- Auto-generate and update documentation
- Validate template integrity before changes
- Show full pre-commit output in responses
- Explain what the hooks validated

### ❌ DON'T: Quality Shortcuts
- Commit without running quality checks
- Create files without proper documentation
- Break existing template functionality
- Hide pre-commit hook output from user

## Development Workflow

### Before Writing ANY Code:
```bash
./CONSTRUCT/scripts/before_coding.sh ComponentName    # Shows what exists
./CONSTRUCT/scripts/check-architecture.sh             # Validates patterns
./CONSTRUCT/scripts/update-context.sh                 # Updates this context
```

### When Making Commits:
Always show the full pre-commit output and explain what was validated.

Example response format:
```
I'll commit these changes. Here's the pre-commit hook output:
[SHOW FULL OUTPUT]
The commit was successful! The hooks validated...
```

## Post-Commit Behavior
After commits, you may see deletions of structure files - this is normal cleanup:
- New structure files generated during pre-commit
- Old structure files cleaned up after commit
- Only current files remain, old ones moved to _old/
- These deletions are NOT errors and should NOT be "fixed"

## Integration
This pattern activates when:
- Working on files matching `CONSTRUCT/**/*`
- Editing shell scripts in the CONSTRUCT system
- Contributing to CONSTRUCT development infrastructure

# [SWIFT] Swift/SwiftUI Development Patterns

## When to Use
- When working with Swift source files (*.swift)
- When developing iOS, macOS, watchOS, or tvOS applications
- When implementing SwiftUI views and ViewModels

## Core Swift/SwiftUI Rules

### ✅ DO: Foundation Rules
```swift
// Never use hardcoded values
❌ NEVER: .frame(width: 200, height: 56)
✅ ALWAYS: .frame(width: tokens.elementWidth, height: tokens.buttonHeight)

// Business logic belongs in ViewModels
❌ NEVER: Business logic in Views
✅ ALWAYS: Business logic in ViewModels

// Use coordinator pattern for navigation
❌ NEVER: NavigationLink(destination: SomeView())
✅ ALWAYS: coordinator.navigate(to: .someFeature)
```

### ✅ DO: iOS Configuration Rules
```swift
// Configuration belongs in configuration files, not code
❌ NEVER: Device orientation in code (App.swift, View.onAppear, etc.)
✅ ALWAYS: Device orientation in Xcode project settings or Info.plist

❌ NEVER: App permissions configured in code
✅ ALWAYS: App permissions in Info.plist with proper descriptions

❌ NEVER: Build settings or capabilities in code
✅ ALWAYS: Build settings in Xcode configuration

❌ NEVER: Launch screen setup in code
✅ ALWAYS: Launch screen via Storyboard or Info.plist
```

### ✅ DO: Swift 6 Concurrency Rules
```swift
// All UI updates must be on MainActor
❌ NEVER: Update UI from background thread
✅ ALWAYS: Use @MainActor for all UI updates

❌ NEVER: DispatchQueue.main.async in ViewModels
✅ ALWAYS: async/await with @MainActor

❌ NEVER: Completion handlers for async operations
✅ ALWAYS: async throws patterns
```

## MVVM Architecture

### ✅ DO: State Management
```swift
// Use @Published in ViewModels for business state
❌ NEVER: @State for business data (users, products, etc.)
✅ ALWAYS: @Published properties in ViewModels for business state

// Keep business logic in ViewModel
❌ NEVER: Business logic in View (calculations, API calls, data transformation)
✅ ALWAYS: Business logic in ViewModel or Service

// Follow proper dependency flow
❌ NEVER: View directly accessing Services/Managers
✅ ALWAYS: View → ViewModel → Service

// Use correct property wrappers
❌ NEVER: @ObservedObject for owned ViewModels
✅ ALWAYS: @StateObject for ViewModels created by the View
```

### ✅ DO: Correct MVVM Pattern
```swift
// View (UI only - no business logic)
struct PaymentView: View {
    @StateObject private var viewModel = PaymentViewModel()
    @State private var isShowingError = false  // UI state only
    
    var body: some View {
        VStack {
            Text("Total: \(viewModel.formattedTotal)")
            
            Button("Calculate Total") {
                Task {
                    await viewModel.calculateTotal()
                }
            }
            .disabled(viewModel.isCalculating)
            
            if viewModel.isCalculating {
                ProgressView()
            }
        }
        .alert("Error", isPresented: $isShowingError) {
            Button("OK") { }
        } message: {
            Text(viewModel.errorMessage)
        }
        .onReceive(viewModel.$hasError) { hasError in
            isShowingError = hasError
        }
    }
}

// ViewModel (Business Logic)
@MainActor
class PaymentViewModel: ObservableObject {
    @Published private(set) var formattedTotal = "$0.00"
    @Published private(set) var isCalculating = false
    @Published private(set) var hasError = false
    @Published private(set) var errorMessage = ""
    
    private let paymentService: PaymentServiceProtocol
    
    init(paymentService: PaymentServiceProtocol = PaymentService()) {
        self.paymentService = paymentService
    }
    
    func calculateTotal() async {
        isCalculating = true
        hasError = false
        
        do {
            let total = try await paymentService.calculateTotal()
            formattedTotal = formatCurrency(total)
        } catch {
            errorMessage = error.localizedDescription
            hasError = true
        }
        
        isCalculating = false
    }
    
    private func formatCurrency(_ amount: Double) -> String {
        return String(format: "$%.2f", amount)
    }
}
```

## Modern SwiftUI Patterns

### ✅ DO: Modern SwiftUI (iOS 15+)
```swift
// Use modern navigation
❌ NEVER: NavigationView (iOS 16+)
✅ ALWAYS: NavigationStack or NavigationView with .navigationViewStyle(.stack)

// Use modern async patterns
❌ NEVER: onChange with async work
✅ ALWAYS: .task modifier for async operations
```

### ✅ DO: Performance Patterns
```swift
// Use lazy containers for large lists
❌ NEVER: VStack/HStack with 50+ static items
✅ ALWAYS: LazyVStack/LazyHStack for lists

// Ensure stable identifiers
❌ NEVER: ForEach without id parameter or unstable IDs
✅ ALWAYS: ForEach with Identifiable or stable id: \.property
```

## Critical Visual Quality

### ✅ DO: Background Flash Prevention
```swift
// MANDATORY: Prevent white flash artifacts
❌ NEVER: Single background causes flashes
AppColors.darkBackground.ignoresSafeArea()

✅ ALWAYS: Multi-layer prevents flashes
ZStack {
    AppColors.darkBackground
        .ignoresSafeArea(.all, edges: .all)
    AppColors.darkBackground
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .clipped()
}
```

### ✅ DO: Quality Gates Before UI Commits
- [ ] Test all animations for white flashes
- [ ] Test sheet presentations and drag gestures
- [ ] Verify background coverage during view transitions
- [ ] Confirm no white artifacts on device edges

## Accessibility Requirements

### ✅ DO: Accessibility Standards
```swift
// All images need descriptive labels
❌ NEVER: Image without .accessibilityLabel
✅ ALWAYS: Descriptive labels for all images

// Clear button purposes
❌ NEVER: Button without accessible text or label
✅ ALWAYS: Clear button purposes with text or accessibilityLabel

// Support Dynamic Type
❌ NEVER: Fixed font sizes (.font(.system(size: 17)))
✅ ALWAYS: Dynamic Type support (.font(.body), .font(.title))

// Multiple indicators for state
❌ NEVER: Color as only indicator of state
✅ ALWAYS: Multiple indicators (color + icon + text)
```

## Anti-Patterns to Avoid

### ❌ DON'T: Common Mistakes
```swift
// Business logic in View
struct BadPaymentView: View {
    @State private var items: [Item] = []  // ❌ Business data in View
    @State private var total: Double = 0   // ❌ Calculated data in View
    
    var body: some View {
        Button("Calculate") {
            // ❌ Business logic in View
            total = items.reduce(0) { $0 + $1.price * Double($1.quantity) }
        }
    }
}

// Direct service access from View
struct BadView: View {
    let service = NetworkService.shared  // ❌ Direct service reference
    
    var body: some View {
        Button("Fetch") {
            Task {
                // ❌ View calling service directly
                let data = try await service.fetchData()
            }
        }
    }
}

// ViewModel without @MainActor
class BadViewModel: ObservableObject {
    @Published var data: [Item] = []
    
    func loadData() {
        Task {
            data = await fetchItems()  // ❌ UI update not on MainActor
        }
    }
}
```

## Component Templates

### ✅ DO: New Feature Template
```swift
// 1. Token System First
struct FeatureTokens {
    let screenHeight: CGFloat
    var elementHeight: CGFloat { screenHeight * 0.X }
}

// 2. ViewModel
@MainActor
class FeatureViewModel: ObservableObject {
    @Published var state: State = .initial
}

// 3. View
struct FeatureView: View {
    @StateObject private var viewModel: FeatureViewModel
    private let tokens: FeatureTokens
}
```

### ✅ DO: Service Pattern
```swift
protocol FeatureServiceProtocol {
    func fetchData() async throws -> [Model]
}

class FeatureService: FeatureServiceProtocol {
    // Implementation
}
```

## State Guidelines

### ✅ DO: When @State IS Acceptable (UI-Only)
```swift
// UI-only state
@State private var isShowingSheet = false
@State private var animationAmount = 1.0
@State private var selectedTab = 0

// ❌ WRONG: Business data
@State private var userProfile: User?  // Should be in ViewModel
@State private var products: [Product] = []  // Should be in ViewModel
```

## Integration
This pattern activates when:
- Working with .swift files
- Developing iOS, macOS, watchOS, or tvOS applications
- Creating SwiftUI views and ViewModels
- Implementing Swift-specific functionality

<!-- 
Generated: 2025-07-07 00:15:28 UTC
Source: CONSTRUCT-CORE/CLAUDE-BASE.md
Plugins: tooling/shell-scripting,cross-platform/model-sync,tooling/construct-dev,languages/swift
Hash: 48b3cfec267d2ecb23d1b181e330bdc004c473fd9b0dafc4faa84ea341b4e496
-->

