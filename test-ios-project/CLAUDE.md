<!-- 
╔══════════════════════════════════════════════════════════════════════════════╗
║                           DO NOT EDIT THIS FILE                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║ This is a GENERATED file, like a compiled binary. Manual edits will be lost. ║
║                                                                              ║
║ To modify patterns:                                                          ║
║ 1. Edit .construct/patterns.yaml for project-specific rules                  ║
║ 2. Create new plugins in CONSTRUCT-LAB/patterns/plugins/                     ║
║ 3. Run: construct-patterns regenerate                                        ║
║                                                                              ║
║ Think of this like Photoshop's .exe - you don't edit the binary!           ║
║                                                                              ║
║ See: CONSTRUCT-CORE/patterns/PATTERN-GUIDE.md for customization help        ║
╚══════════════════════════════════════════════════════════════════════════════╝
-->

# CONSTRUCT Development Context

## Universal Development Principles

These core principles apply to ALL development work, regardless of language or platform:

### ✅ DO: Foundation Rules
- **Never break existing tests** - Changes must maintain backward compatibility
- **Document why, not what** - Code should be self-explanatory, comments explain reasoning
- **Error handling is mandatory** - All failure modes must be handled gracefully
- **Security first** - Never expose secrets, validate all inputs, follow security best practices
- **Performance awareness** - Consider impact of changes on system performance

### ❌ DON'T: Universal Anti-patterns
- Hardcoded values that should be configurable
- Silent failures without error reporting
- Breaking changes without proper versioning
- Security vulnerabilities (exposed secrets, unvalidated inputs)
- Code without proper testing

## Multi-Context Awareness

This context system understands your entire project ecosystem. When you mention files, entities, or tasks, I'll automatically apply the appropriate patterns based on:

- **File extensions** (*.swift, *.cs, *.ts, *.sh, etc.)
- **Directory structure** (CONSTRUCT/**, Models/, Services/, etc.)
- **Project type** (iOS app, web API, full-stack application)
- **Task context** (adding features, fixing bugs, refactoring)

## Pattern System Overview

Your development patterns are organized as plugins that can be mixed and matched based on your project needs:

### Base Patterns (Always Active)
- Universal development principles
- Security and performance standards
- Documentation requirements
- Testing standards

### Language Patterns
- Swift/iOS development patterns
- C#/.NET backend patterns
- TypeScript/JavaScript patterns
- Shell scripting standards

### Architectural Patterns
- MVVM for client applications
- Clean Architecture for backends
- Microservices patterns
- API design standards

### Cross-Platform Patterns
- Model synchronization across stack
- API contract management
- Multi-language coordination

### Tooling Patterns
- CONSTRUCT development workflow
- CI/CD pipeline standards
- Development tools and scripts

## How Pattern Selection Works

Patterns are automatically activated based on your project configuration and the files you're working with. You can also explicitly enable/disable patterns by updating your project's pattern configuration.

### Dynamic Context Application
When you mention specific tasks or files, I'll automatically focus on the relevant patterns:

- Working on a Swift View → Swift language + MVVM patterns
- Updating an API endpoint → Backend patterns + cross-platform considerations
- Writing shell scripts → Shell scripting + tooling patterns
- CONSTRUCT development → CONSTRUCT-specific workflow patterns

## Development Quality Standards

### Code Quality
- All code must be readable and maintainable
- Follow language-specific style guides and conventions
- Use appropriate design patterns for the context
- Implement proper error handling and logging

### Testing Requirements
- Unit tests for business logic
- Integration tests for API endpoints
- UI tests for critical user flows
- Performance tests for bottlenecks

### Documentation Standards
- README files for all projects and major components
- API documentation for public interfaces
- Architectural decision records for significant choices
- Code comments for complex logic or business rules

### Security Standards
- Never commit secrets or API keys
- Validate all user inputs
- Use parameterized queries for database access
- Implement proper authentication and authorization
- Follow OWASP guidelines for web applications

## Pattern Configuration

Below you'll see which patterns are currently active for your project. You can toggle patterns on/off by editing your project's `.construct/patterns.yaml` file and regenerating this context.

To modify patterns:
1. Edit `.construct/patterns.yaml` for project-specific rules
2. Create new plugins in `CONSTRUCT-LAB/patterns/plugins/` for reusable patterns
3. Run `construct-patterns regenerate` to update this file

**Remember**: This file is generated automatically. Don't edit it directly - use the pattern configuration system instead.

## 🧠 Context Intelligence

### Active Language Contexts
Based on your project structure, I'll apply the appropriate patterns:

| File Pattern | Context Applied |
|-------------|-----------------|
| *.swift, *.xcodeproj | Swift patterns |
| *.cs, *.csproj | C# patterns |
| *.ts, *.tsx | TypeScript patterns |
| CONSTRUCT/**/*.sh | CONSTRUCT development |

### Cross-Platform Awareness
When you mention entities that exist across your stack, I'll consider all implementations:
- "User model" → Check Swift, C#, and TypeScript versions
- "API endpoint" → Consider backend implementation and client consumers
- "Update schema" → Propagate through all layers


## 🎛️ Pattern Configuration

### Active Patterns (Toggle ✓/✗ to enable/disable)
- ✓ tooling/shell-scripting
- ✓ languages/swift


# [SHELL] Modern Shell Scripting Standards

## When to Use
- When writing or modifying shell scripts (*.sh files)
- When creating bash automation or tooling
- For any shell-based scripting tasks

## Essential Patterns

### ✅ DO: Script Structure
```bash
#!/bin/bash

# Script Name - Brief Description
# Detailed explanation of what this script does

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
```

### ✅ DO: Error Handling
- Always use `set -e` for automatic error handling
- Check exit codes and provide feedback
- Provide meaningful error messages with context
- Use colored output for status indicators

### ✅ DO: Function Documentation
```bash
# Function description
# Parameters:
#   $1 - Description of first parameter
#   $2 - Description of second parameter  
# Returns:
#   0 on success, 1 on failure
function_name() {
    local param1="$1"
    local param2="$2"
    
    # Validation
    if [ -z "$param1" ]; then
        echo -e "${RED}❌ Error: param1 required${NC}" >&2
        return 1
    fi
    
    # Implementation
    echo -e "${GREEN}✅ Success${NC}"
    return 0
}
```

### ✅ DO: Variable Naming
- Use UPPER_CASE for global variables and environment variables
- Use local variables in functions
- Provide clear, descriptive variable names
- Quote variables to handle spaces: `"$variable"`

### ✅ DO: Path Handling
- Use relative paths and configuration
- Resolve paths dynamically, never hardcode
- Use `$(cd ... && pwd)` for absolute path resolution

### ❌ DON'T: Anti-patterns
- Hardcoded paths (breaks portability)
- Scripts without `set -e` (silent failures)
- Functions without documentation
- Global variables without UPPER_CASE naming
- Commands without error checking
- Silent operations (no user feedback)
- Unquoted variables that might contain spaces

### ❌ DON'T: Bad Examples
```bash
# BAD: Hardcoded paths
SCRIPT_DIR="/Users/username/project/scripts"

# BAD: No error handling
#!/bin/bash
# Missing: set -e
command_that_might_fail
next_command  # Runs even if previous failed

# BAD: No validation
cp "$1" "$2"  # No check if parameters exist

# BAD: Silent operations
find . -name "*.tmp" -delete  # No feedback to user

# BAD: Global variables without clear naming
result="some value"  # Should be RESULT or local

# BAD: Functions without documentation
process_files() {
    # What does this do? What parameters? What returns?
}
```

## Configuration-Driven Patterns

### ✅ DO: External Configuration
```bash
# Load configuration from external files
load_config() {
    local config_file="$PROJECT_ROOT/config/settings.yaml"
    
    if [ ! -f "$config_file" ]; then
        echo -e "${RED}❌ Config file not found: $config_file${NC}" >&2
        return 1
    fi
    
    # Parse and apply configuration
}
```

### ✅ DO: Help and Usage
```bash
# Show help if requested
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: $0 [options]"
    echo "Description of script and options"
    echo ""
    echo "Options:"
    echo "  --help, -h    Show this help"
    exit 0
fi
```

## Library Integration

### ✅ DO: Source Library Functions
```bash
# Source library functions (with validation)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Source common libraries
if [ -f "$PROJECT_ROOT/lib/common.sh" ]; then
    source "$PROJECT_ROOT/lib/common.sh"
else
    echo "❌ Error: Required library not found: lib/common.sh" >&2
    exit 1
fi
```

### ✅ DO: Reusable Functions
- Extract common patterns into lib/ functions
- Share validation logic across scripts
- Create utilities for file analysis and processing

## Output Standards

### ✅ DO: Consistent Output Format
```bash
echo -e "${BLUE}🔍 Starting process...${NC}"
echo -e "${YELLOW}⚠️ Warning message${NC}"
echo -e "${RED}❌ Error message${NC}"
echo -e "${GREEN}✅ Success message${NC}"
```

### ✅ DO: Status Indicators
- Use emoji and colors for clear status
- Provide progress feedback for long operations
- Show summary results at completion

## Integration
This pattern activates when:
- Working on files with `.sh` extension
- Creating bash scripts or automation
- Writing shell-based tooling

# [SWIFT] Swift/SwiftUI Development Patterns

## When to Use
- When working with Swift source files (*.swift)
- When developing iOS, macOS, watchOS, or tvOS applications
- When implementing SwiftUI views and ViewModels

## Core Swift/SwiftUI Rules

### ✅ DO: Foundation Rules
```swift
// Never use hardcoded values
❌ NEVER: .frame(width: 200, height: 56)
✅ ALWAYS: .frame(width: tokens.elementWidth, height: tokens.buttonHeight)

// Business logic belongs in ViewModels
❌ NEVER: Business logic in Views
✅ ALWAYS: Business logic in ViewModels

// Use coordinator pattern for navigation
❌ NEVER: NavigationLink(destination: SomeView())
✅ ALWAYS: coordinator.navigate(to: .someFeature)
```

### ✅ DO: iOS Configuration Rules
```swift
// Configuration belongs in configuration files, not code
❌ NEVER: Device orientation in code (App.swift, View.onAppear, etc.)
✅ ALWAYS: Device orientation in Xcode project settings or Info.plist

❌ NEVER: App permissions configured in code
✅ ALWAYS: App permissions in Info.plist with proper descriptions

❌ NEVER: Build settings or capabilities in code
✅ ALWAYS: Build settings in Xcode configuration

❌ NEVER: Launch screen setup in code
✅ ALWAYS: Launch screen via Storyboard or Info.plist
```

### ✅ DO: Swift 6 Concurrency Rules
```swift
// All UI updates must be on MainActor
❌ NEVER: Update UI from background thread
✅ ALWAYS: Use @MainActor for all UI updates

❌ NEVER: DispatchQueue.main.async in ViewModels
✅ ALWAYS: async/await with @MainActor

❌ NEVER: Completion handlers for async operations
✅ ALWAYS: async throws patterns
```

## MVVM Architecture

### ✅ DO: State Management
```swift
// Use @Published in ViewModels for business state
❌ NEVER: @State for business data (users, products, etc.)
✅ ALWAYS: @Published properties in ViewModels for business state

// Keep business logic in ViewModel
❌ NEVER: Business logic in View (calculations, API calls, data transformation)
✅ ALWAYS: Business logic in ViewModel or Service

// Follow proper dependency flow
❌ NEVER: View directly accessing Services/Managers
✅ ALWAYS: View → ViewModel → Service

// Use correct property wrappers
❌ NEVER: @ObservedObject for owned ViewModels
✅ ALWAYS: @StateObject for ViewModels created by the View
```

### ✅ DO: Correct MVVM Pattern
```swift
// View (UI only - no business logic)
struct PaymentView: View {
    @StateObject private var viewModel = PaymentViewModel()
    @State private var isShowingError = false  // UI state only
    
    var body: some View {
        VStack {
            Text("Total: \(viewModel.formattedTotal)")
            
            Button("Calculate Total") {
                Task {
                    await viewModel.calculateTotal()
                }
            }
            .disabled(viewModel.isCalculating)
            
            if viewModel.isCalculating {
                ProgressView()
            }
        }
        .alert("Error", isPresented: $isShowingError) {
            Button("OK") { }
        } message: {
            Text(viewModel.errorMessage)
        }
        .onReceive(viewModel.$hasError) { hasError in
            isShowingError = hasError
        }
    }
}

// ViewModel (Business Logic)
@MainActor
class PaymentViewModel: ObservableObject {
    @Published private(set) var formattedTotal = "$0.00"
    @Published private(set) var isCalculating = false
    @Published private(set) var hasError = false
    @Published private(set) var errorMessage = ""
    
    private let paymentService: PaymentServiceProtocol
    
    init(paymentService: PaymentServiceProtocol = PaymentService()) {
        self.paymentService = paymentService
    }
    
    func calculateTotal() async {
        isCalculating = true
        hasError = false
        
        do {
            let total = try await paymentService.calculateTotal()
            formattedTotal = formatCurrency(total)
        } catch {
            errorMessage = error.localizedDescription
            hasError = true
        }
        
        isCalculating = false
    }
    
    private func formatCurrency(_ amount: Double) -> String {
        return String(format: "$%.2f", amount)
    }
}
```

## Modern SwiftUI Patterns

### ✅ DO: Modern SwiftUI (iOS 15+)
```swift
// Use modern navigation
❌ NEVER: NavigationView (iOS 16+)
✅ ALWAYS: NavigationStack or NavigationView with .navigationViewStyle(.stack)

// Use modern async patterns
❌ NEVER: onChange with async work
✅ ALWAYS: .task modifier for async operations
```

### ✅ DO: Performance Patterns
```swift
// Use lazy containers for large lists
❌ NEVER: VStack/HStack with 50+ static items
✅ ALWAYS: LazyVStack/LazyHStack for lists

// Ensure stable identifiers
❌ NEVER: ForEach without id parameter or unstable IDs
✅ ALWAYS: ForEach with Identifiable or stable id: \.property
```

## Critical Visual Quality

### ✅ DO: Background Flash Prevention
```swift
// MANDATORY: Prevent white flash artifacts
❌ NEVER: Single background causes flashes
AppColors.darkBackground.ignoresSafeArea()

✅ ALWAYS: Multi-layer prevents flashes
ZStack {
    AppColors.darkBackground
        .ignoresSafeArea(.all, edges: .all)
    AppColors.darkBackground
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .clipped()
}
```

### ✅ DO: Quality Gates Before UI Commits
- [ ] Test all animations for white flashes
- [ ] Test sheet presentations and drag gestures
- [ ] Verify background coverage during view transitions
- [ ] Confirm no white artifacts on device edges

## Accessibility Requirements

### ✅ DO: Accessibility Standards
```swift
// All images need descriptive labels
❌ NEVER: Image without .accessibilityLabel
✅ ALWAYS: Descriptive labels for all images

// Clear button purposes
❌ NEVER: Button without accessible text or label
✅ ALWAYS: Clear button purposes with text or accessibilityLabel

// Support Dynamic Type
❌ NEVER: Fixed font sizes (.font(.system(size: 17)))
✅ ALWAYS: Dynamic Type support (.font(.body), .font(.title))

// Multiple indicators for state
❌ NEVER: Color as only indicator of state
✅ ALWAYS: Multiple indicators (color + icon + text)
```

## Anti-Patterns to Avoid

### ❌ DON'T: Common Mistakes
```swift
// Business logic in View
struct BadPaymentView: View {
    @State private var items: [Item] = []  // ❌ Business data in View
    @State private var total: Double = 0   // ❌ Calculated data in View
    
    var body: some View {
        Button("Calculate") {
            // ❌ Business logic in View
            total = items.reduce(0) { $0 + $1.price * Double($1.quantity) }
        }
    }
}

// Direct service access from View
struct BadView: View {
    let service = NetworkService.shared  // ❌ Direct service reference
    
    var body: some View {
        Button("Fetch") {
            Task {
                // ❌ View calling service directly
                let data = try await service.fetchData()
            }
        }
    }
}

// ViewModel without @MainActor
class BadViewModel: ObservableObject {
    @Published var data: [Item] = []
    
    func loadData() {
        Task {
            data = await fetchItems()  // ❌ UI update not on MainActor
        }
    }
}
```

## Component Templates

### ✅ DO: New Feature Template
```swift
// 1. Token System First
struct FeatureTokens {
    let screenHeight: CGFloat
    var elementHeight: CGFloat { screenHeight * 0.X }
}

// 2. ViewModel
@MainActor
class FeatureViewModel: ObservableObject {
    @Published var state: State = .initial
}

// 3. View
struct FeatureView: View {
    @StateObject private var viewModel: FeatureViewModel
    private let tokens: FeatureTokens
}
```

### ✅ DO: Service Pattern
```swift
protocol FeatureServiceProtocol {
    func fetchData() async throws -> [Model]
}

class FeatureService: FeatureServiceProtocol {
    // Implementation
}
```

## State Guidelines

### ✅ DO: When @State IS Acceptable (UI-Only)
```swift
// UI-only state
@State private var isShowingSheet = false
@State private var animationAmount = 1.0
@State private var selectedTab = 0

// ❌ WRONG: Business data
@State private var userProfile: User?  // Should be in ViewModel
@State private var products: [Product] = []  // Should be in ViewModel
```

## Integration
This pattern activates when:
- Working with .swift files
- Developing iOS, macOS, watchOS, or tvOS applications
- Creating SwiftUI views and ViewModels
- Implementing Swift-specific functionality

<!-- 
Generated: 2025-07-07 01:40:01 UTC
Source: CONSTRUCT-CORE/CLAUDE-BASE.md
Plugins: tooling/shell-scripting,languages/swift
Hash: bbcbf56bc93aca0d4eb40317d6bed4d5db720ebf01c0251c2e4e61c780ca61f2
-->

